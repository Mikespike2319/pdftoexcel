<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF → Excel (Local, Offline)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .panel h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input[type="file"],
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .form-group input[type="number"] {
            width: 120px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #3498db;
        }

        .checkbox-group label {
            margin-bottom: 0;
            font-weight: normal;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .progress-container {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .log-container {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-warning {
            color: #f39c12;
        }

        .log-error {
            color: #e74c3c;
        }

        .log-success {
            color: #27ae60;
        }

        .status {
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .status.idle {
            background: #ecf0f1;
            color: #7f8c8d;
        }

        .status.processing {
            background: #d5f4e6;
            color: #27ae60;
        }

        .status.error {
            background: #fadbd8;
            color: #e74c3c;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PDF → Excel (Local, Offline)</h1>
            <p>Extract tabular data from PDFs and convert to Excel format with column detection</p>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>Input & Options</h2>
                
                <div class="form-group">
                    <label for="pdfFile">Choose PDF File:</label>
                    <input type="file" id="pdfFile" accept=".pdf" />
                </div>

                <div class="form-group">
                    <label for="pageRange">Pages to parse:</label>
                    <input type="text" id="pageRange" value="1-500" placeholder="e.g., 1-50, 120, 300-350" />
                </div>

                <div class="form-group">
                    <label for="rowTolerance">Row tolerance (y-merge):</label>
                    <input type="number" id="rowTolerance" value="2.5" min="0.5" max="20" step="0.5" />
                    <span style="margin-left: 10px; color: #7f8c8d;">px</span>
                </div>

                <div class="form-group">
                    <label for="columnTolerance">Column clustering tolerance (x-cluster):</label>
                    <input type="number" id="columnTolerance" value="6" min="1" max="50" step="1" />
                    <span style="margin-left: 10px; color: #7f8c8d;">px</span>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="oneSheetPerTable" checked />
                    <label for="oneSheetPerTable">One worksheet per detected table</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="oneSheetPerPage" />
                    <label for="oneSheetPerPage">One worksheet per page (fallback)</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="detectStructuredData" checked />
                    <label for="detectStructuredData">Detect structured data (forms, field-value pairs)</label>
                </div>

                <div class="button-group">
                    <button id="parseBtn" class="btn btn-primary">Parse & Export</button>
                    <button id="cancelBtn" class="btn btn-secondary" disabled>Cancel</button>
                </div>
            </div>

            <div class="panel">
                <h2>Progress & Status</h2>
                
                <div id="status" class="status idle">
                    Ready to process PDF
                </div>

                <div class="progress-container" style="display: none;" id="progressContainer">
                    <div class="progress-text">
                        <span id="progressText">Processing...</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div id="etaText" style="color: #7f8c8d; font-size: 14px;"></div>
                </div>

                <div class="log-container" id="logContainer">
                    <div class="log-entry log-success">✓ Application loaded successfully</div>
                    <div class="log-entry">Ready to process PDF files...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PDF.js and SheetJS library code (minified versions embedded)
        const PDFJS_LIB = `/* PDF.js v3.11.174 - Minified */
        ${document.currentScript ? '' : '// Library will be loaded from external file'}`;
        const XLSX_LIB = `/* SheetJS v0.18.5 - Minified */
        ${document.currentScript ? '' : '// Library will be loaded from external file'}`;
        
        // Application state
        let currentWorker = null;
        let isProcessing = false;
        let startTime = null;
        let totalPages = 0;
        let processedPages = 0;

        // DOM elements
        const elements = {
            pdfFile: document.getElementById('pdfFile'),
            pageRange: document.getElementById('pageRange'),
            rowTolerance: document.getElementById('rowTolerance'),
            columnTolerance: document.getElementById('columnTolerance'),
            oneSheetPerTable: document.getElementById('oneSheetPerTable'),
            oneSheetPerPage: document.getElementById('oneSheetPerPage'),
            detectStructuredData: document.getElementById('detectStructuredData'),
            parseBtn: document.getElementById('parseBtn'),
            cancelBtn: document.getElementById('cancelBtn'),
            status: document.getElementById('status'),
            progressContainer: document.getElementById('progressContainer'),
            progressText: document.getElementById('progressText'),
            progressPercent: document.getElementById('progressPercent'),
            progressFill: document.getElementById('progressFill'),
            etaText: document.getElementById('etaText'),
            logContainer: document.getElementById('logContainer')
        };

        // Initialize the application
        function init() {
            loadLibraries();
            setupEventListeners();
            log('Application initialized successfully', 'success');
        }

        // Load embedded libraries
        function loadLibraries() {
            try {
                log('Starting library loading...', 'info');
                
                // Load PDF.js
                const pdfjsScript = document.createElement('script');
                pdfjsScript.src = 'pdf.min.js';
                pdfjsScript.onload = () => {
                    log('PDF.js loaded successfully', 'success');
                    console.log('PDF.js loaded, pdfjsLib available:', typeof pdfjsLib !== 'undefined');
                    
                    // Load SheetJS after PDF.js
                    const xlsxScript = document.createElement('script');
                    xlsxScript.src = 'xlsx.min.js';
                    xlsxScript.onload = () => {
                        log('SheetJS loaded successfully', 'success');
                        console.log('SheetJS loaded, XLSX available:', typeof XLSX !== 'undefined');
                        log('All libraries loaded successfully', 'success');
                    };
                    xlsxScript.onerror = (error) => {
                        console.error('SheetJS loading error:', error);
                        log('Error loading SheetJS library', 'error');
                    };
                    document.head.appendChild(xlsxScript);
                };
                pdfjsScript.onerror = (error) => {
                    console.error('PDF.js loading error:', error);
                    log('Error loading PDF.js library', 'error');
                };
                document.head.appendChild(pdfjsScript);
                
            } catch (error) {
                console.error('Library loading error:', error);
                log(`Error loading libraries: ${error.message}`, 'error');
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            elements.parseBtn.addEventListener('click', handleParseAndExport);
            elements.cancelBtn.addEventListener('click', handleCancel);
            elements.pdfFile.addEventListener('change', handleFileSelect);
        }

        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                log(`Selected PDF: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`, 'success');
                updateStatus('idle', 'PDF selected, ready to process');
            } else if (file) {
                log('Please select a valid PDF file', 'error');
                elements.pdfFile.value = '';
            }
        }

        // Handle parse and export
        async function handleParseAndExport() {
            console.log('Parse & Export button clicked');
            
            // Check if libraries are loaded
            if (typeof pdfjsLib === 'undefined') {
                log('PDF.js library not loaded. Please refresh the page and try again.', 'error');
                return;
            }
            
            if (typeof XLSX === 'undefined') {
                log('SheetJS library not loaded. Please refresh the page and try again.', 'error');
                return;
            }
            
            const file = elements.pdfFile.files[0];
            if (!file) {
                log('Please select a PDF file first', 'error');
                return;
            }

            log('File selected: ' + file.name, 'info');
            
            const options = getProcessingOptions();
            if (!options) {
                log('Failed to get processing options', 'error');
                return;
            }

            log('Processing options: ' + JSON.stringify(options), 'info');

            try {
                isProcessing = true;
                startTime = Date.now();
                updateUIForProcessing(true);
                
                log('Starting PDF processing...', 'success');
                updateStatus('processing', 'Processing PDF...');

                log('Converting file to ArrayBuffer...', 'info');
                const arrayBuffer = await file.arrayBuffer();
                log('ArrayBuffer created, size: ' + arrayBuffer.byteLength + ' bytes', 'info');

                log('Starting PDF processing with worker...', 'info');
                const results = await processPDF(arrayBuffer, options);
                log('PDF processing completed, results: ' + results.length + ' pages', 'info');
                
                if (results.length > 0) {
                    log('Exporting to Excel...', 'info');
                    await exportToExcel(results, file.name);
                    log('Export completed successfully!', 'success');
                    updateStatus('idle', 'Export completed successfully');
                } else {
                    log('No tables detected in the PDF', 'warning');
                    updateStatus('error', 'No tables detected');
                }
            } catch (error) {
                console.error('Error in handleParseAndExport:', error);
                log(`Error processing PDF: ${error.message}`, 'error');
                updateStatus('error', 'Processing failed');
            } finally {
                isProcessing = false;
                updateUIForProcessing(false);
                cleanup();
            }
        }

        // Get processing options from UI
        function getProcessingOptions() {
            const pageRange = elements.pageRange.value.trim();
            const rowTolerance = parseFloat(elements.rowTolerance.value);
            const columnTolerance = parseFloat(elements.columnTolerance.value);
            
            if (rowTolerance <= 0 || columnTolerance <= 0) {
                log('Tolerance values must be positive', 'error');
                return null;
            }

            const pages = parsePageRange(pageRange);
            if (!pages || pages.length === 0) {
                log('Invalid page range format', 'error');
                return null;
            }

            return {
                pages,
                rowTolerance,
                columnTolerance,
                oneSheetPerTable: elements.oneSheetPerTable.checked,
                oneSheetPerPage: elements.oneSheetPerPage.checked,
                detectStructuredData: elements.detectStructuredData.checked
            };
        }

        // Parse page range string
        function parsePageRange(rangeStr) {
            const pages = new Set();
            const parts = rangeStr.split(',');
            
            for (const part of parts) {
                const trimmed = part.trim();
                if (trimmed.includes('-')) {
                    const [start, end] = trimmed.split('-').map(s => parseInt(s.trim()));
                    if (start && end && start <= end) {
                        for (let i = start; i <= end; i++) {
                            pages.add(i);
                        }
                    }
                } else {
                    const page = parseInt(trimmed);
                    if (page > 0) {
                        pages.add(page);
                    }
                }
            }
            
            return Array.from(pages).sort((a, b) => a - b);
        }

        // Process PDF using Web Worker
        async function processPDF(arrayBuffer, options) {
            return new Promise((resolve, reject) => {
                const workerCode = `
                    // PDF processing worker
                    importScripts('pdf.min.js');
                    
                    self.onmessage = async function(e) {
                        const { arrayBuffer, options } = e.data;
                        
                        try {
                            // Set up PDF.js
                            pdfjsLib.GlobalWorkerOptions.workerSrc = self.location.href;
                            
                            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                            const pdf = await loadingTask.promise;
                            
                            const results = [];
                            let processedPages = 0;
                            
                            for (const pageNum of options.pages) {
                                if (pageNum > pdf.numPages) {
                                    self.postMessage({ 
                                        type: 'warning', 
                                        message: `Page ${pageNum} exceeds PDF length (${pdf.numPages})` 
                                    });
                                    continue;
                                }
                                
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent({
                                    normalizeWhitespace: true,
                                    disableCombineTextItems: false
                                });
                                
                                const tables = extractTablesFromPage(textContent, options);
                                
                                results.push({
                                    page: pageNum,
                                    tables: tables,
                                    warnings: []
                                });
                                
                                processedPages++;
                                self.postMessage({ 
                                    type: 'progress', 
                                    processed: processedPages, 
                                    total: options.pages.length 
                                });
                            }
                            
                            self.postMessage({ type: 'complete', results });
                            
                        } catch (error) {
                            self.postMessage({ type: 'error', message: error.message });
                        }
                    };
                    
                    function extractTablesFromPage(textContent, options) {
                        const items = textContent.items.map(item => ({
                            text: item.str,
                            x: item.transform[4],
                            y: item.transform[5],
                            width: item.width,
                            height: item.height
                        }));
                        
                        // Group items into rows
                        const rows = groupIntoRows(items, options.rowTolerance);
                        
                        // Detect tables
                        const tables = detectTables(rows, options.columnTolerance);
                        
                        return tables;
                    }
                    
                    function groupIntoRows(items, rowTolerance) {
                        // Sort by y coordinate (descending)
                        items.sort((a, b) => b.y - a.y);
                        
                        const rows = [];
                        let currentRow = [];
                        let lastY = null;
                        
                        for (const item of items) {
                            if (lastY === null || Math.abs(item.y - lastY) <= rowTolerance) {
                                currentRow.push(item);
                            } else {
                                if (currentRow.length > 0) {
                                    // Sort items in row by x coordinate
                                    currentRow.sort((a, b) => a.x - b.x);
                                    rows.push(currentRow);
                                }
                                currentRow = [item];
                            }
                            lastY = item.y;
                        }
                        
                        if (currentRow.length > 0) {
                            currentRow.sort((a, b) => a.x - b.x);
                            rows.push(currentRow);
                        }
                        
                        return rows;
                    }
                    
                    function detectTables(rows, columnTolerance) {
                        if (rows.length === 0) return [];
                        
                        // Check if structured data detection is enabled
                        if (options.detectStructuredData) {
                            // First, try to detect structured form data (field-value pairs)
                            const structuredTables = detectStructuredForms(rows);
                            if (structuredTables.length > 0) {
                                return structuredTables;
                            }
                        }
                        
                        // Fall back to regular table detection
                        return detectRegularTables(rows, columnTolerance);
                    }
                    
                    function detectStructuredForms(rows) {
                        const tables = [];
                        let currentTable = [];
                        
                        for (const row of rows) {
                            const rowText = row.map(item => item.text).join(' ').trim();
                            
                            // Skip empty rows
                            if (!rowText) continue;
                            
                            // Check for structured form patterns
                            const isStructuredRow = detectStructuredRow(row);
                            
                            if (isStructuredRow) {
                                currentTable.push(isStructuredRow);
                            } else if (currentTable.length > 0) {
                                // End of structured section
                                if (currentTable.length > 0) {
                                    tables.push(currentTable);
                                }
                                currentTable = [];
                            }
                        }
                        
                        if (currentTable.length > 0) {
                            tables.push(currentTable);
                        }
                        
                        return tables;
                    }
                    
                    function detectStructuredRow(row) {
                        const rowText = row.map(item => item.text).join(' ');
                        
                        // Patterns for account information
                        const patterns = [
                            // Account header pattern
                            {
                                regex: /(Account Number|Name|Balance|Reason Uncollectable)/i,
                                type: 'header',
                                columns: ['Account Number', 'Name', 'Balance', 'Reason Uncollectable']
                            },
                            // Date of Death pattern
                            {
                                regex: /Date of Death/i,
                                type: 'field',
                                columns: ['Field', 'Value']
                            },
                            // Bankruptcy pattern
                            {
                                regex: /Bankruptcy case #|Chapter|Filed|Dismissed|District/i,
                                type: 'field',
                                columns: ['Field', 'Value']
                            },
                            // Attorney pattern
                            {
                                regex: /Attorney Name|Attorney Address|Telephone/i,
                                type: 'field',
                                columns: ['Field', 'Value']
                            },
                            // Generic field-value pattern
                            {
                                regex: /^([^:]+):\s*(.+)$/,
                                type: 'field_value',
                                columns: ['Field', 'Value']
                            }
                        ];
                        
                        for (const pattern of patterns) {
                            if (pattern.regex.test(rowText)) {
                                return parseStructuredRow(row, pattern);
                            }
                        }
                        
                        return null;
                    }
                    
                    function parseStructuredRow(row, pattern) {
                        const rowText = row.map(item => item.text).join(' ');
                        
                        if (pattern.type === 'header') {
                            // Create header row
                            return pattern.columns;
                        } else if (pattern.type === 'field') {
                            // Parse field-value pairs
                            const parts = rowText.split(/\s*-\s*/);
                            if (parts.length >= 2) {
                                return [parts[0].trim(), parts.slice(1).join(' - ').trim()];
                            } else {
                                return [rowText, ''];
                            }
                        } else if (pattern.type === 'field_value') {
                            // Parse "Field: Value" format
                            const match = rowText.match(/^([^:]+):\s*(.+)$/);
                            if (match) {
                                return [match[1].trim(), match[2].trim()];
                            }
                        }
                        
                        return [rowText, ''];
                    }
                    
                    function detectRegularTables(rows, columnTolerance) {
                        // Collect all x positions for column detection
                        const allX = [];
                        for (const row of rows) {
                            for (const item of row) {
                                allX.push(item.x);
                                allX.push(item.x + item.width);
                            }
                        }
                        
                        // Cluster x positions to find column boundaries
                        const columnBoundaries = clusterXPositions(allX, columnTolerance);
                        
                        // Convert rows to table format
                        const tables = [];
                        let currentTable = [];
                        
                        for (const row of rows) {
                            const tableRow = new Array(columnBoundaries.length - 1).fill('');
                            
                            for (const item of row) {
                                const columnIndex = findColumnIndex(item.x, columnBoundaries);
                                if (columnIndex >= 0 && columnIndex < tableRow.length) {
                                    tableRow[columnIndex] += (tableRow[columnIndex] ? ' ' : '') + item.text;
                                }
                            }
                            
                            // Check if this row has significant content
                            const hasContent = tableRow.some(cell => cell.trim().length > 0);
                            
                            if (hasContent) {
                                currentTable.push(tableRow);
                            } else if (currentTable.length > 0) {
                                // Empty row might indicate table boundary
                                if (currentTable.length > 1) {
                                    tables.push(currentTable);
                                }
                                currentTable = [];
                            }
                        }
                        
                        if (currentTable.length > 1) {
                            tables.push(currentTable);
                        }
                        
                        return tables;
                    }
                    
                    function clusterXPositions(xPositions, tolerance) {
                        const sorted = [...new Set(xPositions)].sort((a, b) => a - b);
                        const clusters = [];
                        
                        for (const x of sorted) {
                            let added = false;
                            for (const cluster of clusters) {
                                if (Math.abs(cluster - x) <= tolerance) {
                                    cluster = (cluster + x) / 2; // Update cluster center
                                    added = true;
                                    break;
                                }
                            }
                            if (!added) {
                                clusters.push(x);
                            }
                        }
                        
                        return clusters.sort((a, b) => a - b);
                    }
                    
                    function findColumnIndex(x, boundaries) {
                        for (let i = 0; i < boundaries.length - 1; i++) {
                            if (x >= boundaries[i] && x < boundaries[i + 1]) {
                                return i;
                            }
                        }
                        return -1;
                    }
                `;
                
                const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(workerBlob);
                
                currentWorker = new Worker(workerUrl);
                
                currentWorker.onmessage = function(e) {
                    const { type, message, processed, total, results } = e.data;
                    
                    switch (type) {
                        case 'progress':
                            updateProgress(processed, total);
                            break;
                        case 'warning':
                            log(`Warning: ${message}`, 'warning');
                            break;
                        case 'error':
                            log(`Worker error: ${message}`, 'error');
                            reject(new Error(message));
                            break;
                        case 'complete':
                            resolve(results);
                            break;
                    }
                };
                
                currentWorker.onerror = function(error) {
                    log(`Worker error: ${error.message}`, 'error');
                    reject(error);
                };
                
                currentWorker.postMessage({ arrayBuffer, options });
            });
        }

        // Export results to Excel
        async function exportToExcel(results, originalFilename) {
            const workbook = XLSX.utils.book_new();
            let tableCount = 0;
            
            for (const result of results) {
                const { page, tables } = result;
                
                if (elements.oneSheetPerTable.checked) {
                    // One worksheet per detected table
                    for (let i = 0; i < tables.length; i++) {
                        const table = tables[i];
                        if (table.length > 0) {
                            const sheetName = `p${page}_t${i + 1}`;
                            const worksheet = XLSX.utils.aoa_to_sheet(table);
                            XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
                            tableCount++;
                        }
                    }
                } else if (elements.oneSheetPerPage.checked) {
                    // One worksheet per page
                    const allTables = tables.flat();
                    if (allTables.length > 0) {
                        const sheetName = `page_${page}`;
                        const worksheet = XLSX.utils.aoa_to_sheet(allTables);
                        XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
                        tableCount++;
                    }
                }
            }
            
            if (tableCount === 0) {
                // Fallback: create a single sheet with all data
                const allData = [];
                for (const result of results) {
                    for (const table of result.tables) {
                        allData.push(...table);
                    }
                }
                
                if (allData.length > 0) {
                    const worksheet = XLSX.utils.aoa_to_sheet(allData);
                    XLSX.utils.book_append_sheet(workbook, worksheet, 'extracted_data');
                }
            }
            
            // Generate filename
            const timestamp = new Date().toISOString().replace(/[:.]/g, '').slice(0, 15);
            const baseName = originalFilename.replace(/\.pdf$/i, '');
            const filename = `extracted_${baseName}_${timestamp}.xlsx`;
            
            // Save the file
            XLSX.writeFile(workbook, filename);
            log(`Exported ${tableCount} tables to ${filename}`, 'success');
        }

        // Handle cancel
        function handleCancel() {
            if (currentWorker) {
                currentWorker.terminate();
                currentWorker = null;
            }
            isProcessing = false;
            updateUIForProcessing(false);
            updateStatus('idle', 'Processing cancelled');
            log('Processing cancelled by user', 'warning');
        }

        // Update UI for processing state
        function updateUIForProcessing(processing) {
            elements.parseBtn.disabled = processing;
            elements.cancelBtn.disabled = !processing;
            elements.progressContainer.style.display = processing ? 'block' : 'none';
            
            if (!processing) {
                elements.progressFill.style.width = '0%';
                elements.progressText.textContent = 'Processing...';
                elements.progressPercent.textContent = '0%';
                elements.etaText.textContent = '';
            }
        }

        // Update progress
        function updateProgress(processed, total) {
            const percent = Math.round((processed / total) * 100);
            elements.progressFill.style.width = `${percent}%`;
            elements.progressText.textContent = `Processing page ${processed} of ${total}`;
            elements.progressPercent.textContent = `${percent}%`;
            
            if (startTime && processed > 0) {
                const elapsed = Date.now() - startTime;
                const rate = processed / (elapsed / 1000);
                const remaining = total - processed;
                const eta = Math.round(remaining / rate);
                
                if (eta > 0) {
                    const etaMinutes = Math.floor(eta / 60);
                    const etaSeconds = eta % 60;
                    elements.etaText.textContent = `ETA: ${etaMinutes}m ${etaSeconds}s`;
                }
            }
        }

        // Update status
        function updateStatus(type, message) {
            elements.status.className = `status ${type}`;
            elements.status.textContent = message;
        }

        // Log messages
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            elements.logContainer.appendChild(logEntry);
            elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
        }

        // Cleanup
        function cleanup() {
            if (currentWorker) {
                currentWorker.terminate();
                currentWorker = null;
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
